import math
import numpy as np
import os
import bisect

def closest(x, tol):
    """
    Return closest float to standard EIA series.  Threshold is in a log
    sense, which is slightly lower than the arithmetic mean.
    :param x: float to convert
    :param tol: string "e6", "e12", "5%", "10%" etc.
    :return: closest float in specified Exx series, or
             0.0 if input is incorrect.
    """
    # 20% series
    e6  = [1.00, 1.50, 2.20, 3.30, 4.70, 6.80, 10.0]
    # 10% series
    e12 = [1.0, 1.2, 1.5, 1.8, 2.2, 2.7, 3.3, 3.9, 4.7, 5.6, 6.8, 8.2, 10.0]
    # 5% series
    e24 = [1.0, 1.1, 1.2, 1.3, 1.5, 1.6, 1.8, 2.0, 2.2, 2.4, 2.7, 3.0,
           3.3, 3.6, 3.9, 4.3, 4.7, 5.1, 5.6, 6.2, 6.8, 7.5, 8.2, 9.1, 10.0]
    # 2% series
    e48 = [1.00, 1.05, 1.10, 1.15, 1.21, 1.27, 1.33, 1.40, 1.47, 1.54,
           1.62, 1.69, 1.78, 1.87, 1.96, 2.05, 2.15, 2.26, 2.37, 2.49,
           2.61, 2.74, 2.87, 3.01, 3.16, 3.32, 3.48, 3.65, 3.83, 4.02,
           4.22, 4.42, 4.64, 4.87, 5.11, 5.36, 5.62, 5.90, 6.19, 6.49,
           6.81, 7.15, 7.50, 7.87, 8.25, 8.66, 9.09, 9.53, 10.0]
    # 1% series
    e96 = [1.00, 1.02, 1.05, 1.07, 1.10, 1.13, 1.15, 1.18, 1.21, 1.24,
           1.27, 1.30, 1.33, 1.37, 1.40, 1.43, 1.47, 1.50, 1.54, 1.58,
           1.62, 1.65, 1.69, 1.74, 1.78, 1.82, 1.87, 1.91, 1.96, 2.00,
           2.05, 2.10, 2.16, 2.21, 2.26, 2.32, 2.37, 2.43, 2.49, 2.55,
           2.61, 2.67, 2.74, 2.80, 2.87, 2.94, 3.01, 3.09, 3.16, 3.24,
           3.32, 3.40, 3.48, 3.57, 3.65, 3.74, 3.83, 3.92, 4.02, 4.12,
           4.22, 4.32, 4.42, 4.53, 4.64, 4.75, 4.87, 4.99, 5.11, 5.23,
           5.36, 5.49, 5.62, 5.76, 5.90, 6.04, 6.19, 6.34, 6.49, 6.65,
           6.81, 6.98, 7.15, 7.32, 7.50, 7.68, 7.87, 8.06, 8.25, 8.45,
           8.66, 8.87, 9.09, 9.31, 9.53, 9.76, 10.0]
    # .1%, .25%, and .5% series
    e192 = [1.00, 1.01, 1.02, 1.04, 1.05, 1.06, 1.07, 1.09, 1.10, 1.11,
            1.13, 1.14, 1.15, 1.17, 1.18, 1.20, 1.21, 1.23, 1.24, 1.26,
            1.27, 1.29, 1.30, 1.32, 1.33, 1.35, 1.37, 1.38, 1.40, 1.42,
            1.43, 1.45, 1.47, 1.49, 1.50, 1.52, 1.54, 1.56, 1.58, 1.60,
            1.62, 1.64, 1.65, 1.67, 1.69, 1.72, 1.74, 1.76, 1.78, 1.80,
            1.82, 1.84, 1.87, 1.89, 1.91, 1.93, 1.96, 1.98, 2.00, 2.03,
            2.05, 2.08, 2.10, 2.13, 2.15, 2.18, 2.21, 2.23, 2.26, 2.29,
            2.32, 2.34, 2.37, 2.40, 2.43, 2.46, 2.49, 2.52, 2.55, 2.58,
            2.61, 2.64, 2.67, 2.71, 2.74, 2.77, 2.80, 2.84, 2.87, 2.91,
            2.94, 2.98, 3.01, 3.05, 3.09, 3.12, 3.16, 3.20, 3.24, 3.28,
            3.32, 3.36, 3.40, 3.44, 3.48, 3.52, 3.57, 3.61, 3.65, 3.70,
            3.74, 3.79, 3.83, 3.88, 3.92, 3.97, 4.02, 4.07, 4.12, 4.17,
            4.22, 4.27, 4.32, 4.37, 4.42, 4.48, 4.53, 4.59, 4.64, 4.70,
            4.75, 4.81, 4.87, 4.93, 4.99, 5.05, 5.11, 5.17, 5.23, 5.30,
            5.36, 5.42, 5.49, 5.56, 5.62, 5.69, 5.76, 5.83, 5.90, 5.97,
            6.04, 6.12, 6.19, 6.26, 6.34, 6.42, 6.49, 6.57, 6.65, 6.73,
            6.81, 6.90, 6.98, 7.06, 7.15, 7.23, 7.32, 7.41, 7.50, 7.59,
            7.68, 7.77, 7.87, 7.96, 8.06, 8.16, 8.25, 8.35, 8.45, 8.56,
            8.66, 8.76, 8.87, 8.98, 9.09, 9.20, 9.31, 9.42, 9.53, 9.65,
            9.76, 9.88, 10.0]
    if x <= 0.0:
        return 0.0
    if tol == "e6" or tol == "20%":
        list = e6
        sig_d = 2
    elif tol == "e12" or tol == "10%":
        list = e12
        sig_d = 2
    elif tol == "e24" or tol == "5%":
        list = e24
        sig_d = 2
    elif tol == "e48" or tol == "2%":
        list = e48
        sig_d = 3
    elif tol == "e96" or tol == "1%":
        list = e96
        sig_d = 3
    elif tol == "e192" or tol == ".1%" or tol == ".25%" or tol == ".5%":
        list = e192
        sig_d = 3
    else:
        return 0.0
    x_mant, x_exp = frexp10(x)
    # Index to element just lower than or equal to x_mant
    i = bisect.bisect_right(list, x_mant) - 1
    # Lower bound (possibly equal) and upper bound
    l, h = list[i], list[i+1]
    ratio = h/l
    # Make the ratio threshold where x_mant/l = h/x_mant.  This will
    # be a slightly lower value than the arithmetic mean of l and h.
    thresh = math.sqrt(ratio)
    # Find closest value in a log sense
    closest_mant = list[i] if x_mant / list[i] < thresh else list[i+1]
    # May be slight numerical error in result due to math.pow(), follow
    # with eng_notate() if desired to clean up
    return closest_mant * math.pow(10.0, x_exp)


def get_ltspice_complex_plot_export(filename):
    """
    Read a cartesian format complex data file generated by LTspice
    'File / Export, Format = Cartesian' from the waveform viewer.
    :param format:  filename for LTspice exported plot file
    :return: np.arrays of x, magnitude, phase
    """
    # for test:
    #filename = r"C:\Users\Gerrit\Desktop\CableZTest.txt"
    strTarget = os.path.normpath(filename)
    fs = open(strTarget, "r")
    f = iter(fs)
    x, yc = [], []
    # Skip first line
    line = next(f)
    for line in f:
        # Separate first value from complex pair and append it
        xy = line.split("\t")
        x.append(float(xy[0]))
        # Split complex pair and append it
        y = xy[1].split(",")
        cplx = float(y[0]) + 1j*float(y[1])
        yc.append(cplx)
        line = next(f)
    # Make arrays of magnitude and phase from complex data
    ym = np.abs(yc)
    yp = np.angle(yc, deg=True)
    return x, ym, yp


def frexp10(x):
    """
    Return mantissa and exponent (base 10), similar to base-2 frexp()
    :param x: floating point number
    :return: tuple (mantissa, exponent)
    """
    exp = math.floor(math.log10(x))
    return x/10**exp, exp


def eng_notate(x, d=3, suff=True, neg_ok=False):
    """
    Convert a float to a string in engineering units, with specified
    significant digits
    :param x: float to convert
    :param d: number of significant digits
    :param suff: True:  use suffix unit letter
                 False: return scientific notation
    :param neg_ok: True if negative values are ok, False otherwise
    :return: string conversion of x, either scientific notation
             or with suffix
    """
    # Practical component suffixes
    _SUFFIX = ["f", "p", "n", "u", "m", "", "k", "M", "G"]
    # Offset to unit multiplier (no suffix)
    _UNIT_OFFSET = 5

    sign = ""
    if neg_ok and x < 0.0:
        sign = "-"
        x = -x
    if x < 0.0 or not math.isfinite(x):
        return "RangeErr"
    if x == 0:
        return "0.0"
    # Normalize the number and round to get d significant digits
    mant, exp = frexp10(x)
    r = round(mant,d-1)
    # Convert back to original scale
    x = r * math.pow(10.0, exp)
    # Get integer exponent to group by factors of 1000
    p = int(math.floor(math.log10(x)))
    p3 = p // 3
    # Get root value string
    value = x / math.pow(10.0, 3*p3)
    numStr = "{:f}".format(value)
    # Slice to length, avoid trailing "."
    if numStr[d] != ".":
        numStr = numStr[0:d+1]
    else:
        numStr = numStr[0:d]
    # Prepend '-' if necessary
    numStr = sign + numStr
    if suff:
        # Append units suffix
        p3i = p3 + _UNIT_OFFSET
        if p3i < 0:
            # Smaller than lowest unit
            return "<1{}".format(_SUFFIX[0])
        if p3i > len(_SUFFIX)-1:
            # Larger than largest unit
            return ">999{}".format(_SUFFIX[-1])
        else:
            s = _SUFFIX[p3i]
            return "{}{}".format(numStr, s)
    else:
        # No suffix, return floating point string
        if p3 != 0:
            return "{}e{:d}".format(numStr, 3*p3)
        else:
            return "{}".format(numStr)

if __name__ == "__main__":
    # No default program
    pass