# TODO: allow specifying axis limits
# TODO: convert Z magnitude axis to engineering units
# TODO: allow dragging drawn points
# TODO: R / X axes in addition to mag/phase?
# TODO: catch init < min or > max
# TODO: assign space bar to Next button (not last clicked)
# TODO: add percentage option to min/max

# Qt5 bindings for core Qt functionalities (non-GUI)
try:
    # new location for sip
    # https://www.riverbankcomputing.com/static/Docs/PyQt5/incompatibilities.html#pyqt-v5-11
    from PyQt5 import sip
except ImportError:
    import sip
from PyQt5 import QtCore
# Python Qt5 bindings for GUI objects
from PyQt5 import QtWidgets
# UI main window
from ui_Zfit import Ui_MainWindow

class AppMainWindow(QtWidgets.QMainWindow, Ui_MainWindow):
    def __init__(self, parent=None):
        # initialization of the superclass
        super(AppMainWindow, self).__init__(parent)
        # setup the GUI --> function generated by pyuic5
        self.setupUi(self)

        self.prog_bar_tick = 0
        self.plot_file_path = ""

        # Restore last file & path names or empty strings
        filename = reg.get_reg("DataFilename")
        self.lineEditData.setText(filename)
        filename = reg.get_reg("ModelScript")
        self.lineEditModel.setText(filename)
        self.plot_file_path = reg.get_reg("LastPlotPath")
        self.checkBoxLogMag.setChecked(reg.get_reg("LogMag") == "True")
        self.checkBoxLogFreq.setChecked(reg.get_reg("LogFreq") == "True")
        self.do_norm_denorm = reg.get_reg("Normalize") == "True"
        self.radioButtonNormDenormOn.setChecked(self.do_norm_denorm)
        self.radioButtonNormDenormOff.setChecked(not self.do_norm_denorm)

        # To avoid creating multiple error boxes
        self.err_box = None

        # Clear output window text
        self.labelParams.setText("")
        self.labelStatus.setText("")

        # Default drawing selection & labels
        self.radioButtonWeight.setDown(True)
        self.pushButtonDraw.setText('&Draw Weight')
        self.pushButtonDraw.setShortcut('D')
        self.pushButtonClear.setText('&Clear Weight')
        self.pushButtonClear.setShortcut('C')

        # Populate and restore the 'fitting methods' combo box
        method_names = [m[0] for m in METHODS]
        self.comboBoxMethod.addItems(method_names)
        if self.comboBoxMethod.currentIndex() < 0:
            self.comboBoxMethod.setCurrentIndex(0)
            reg.set_reg("MethodIndex", "0")
        else:
            try:
                self.comboBoxMethod.setCurrentIndex(int(reg.get_reg("MethodIndex")))
            except Exception:
                reg.set_reg("MethodIndex", "0")
                self.comboBoxMethod.setCurrentIndex(0)

        # Connect GUI signals to functions
        # Sequence here is left-to-right, top-to-bottom on form:
        self.pushButtonDataFile.clicked.connect(select_data_file)
        self.pushButtonModelScript.clicked.connect(select_model_script)
        self.pushButtonEdit.clicked.connect(edit_model_script)
        self.radioButtonWeight.pressed.connect(draw_weight)
        self.radioButtonMag.pressed.connect(draw_mag)
        self.radioButtonPha.pressed.connect(draw_pha)
        self.pushButtonDraw.clicked.connect(draw_active)
        self.pushButtonClear.clicked.connect(clear_active_axes)
        self.comboBoxMethod.currentIndexChanged.connect(method_update)
        self.pushButtonHelp.clicked.connect(show_help)
        self.pushButtonNext.clicked.connect(next_plot)
        self.checkBoxLogMag.stateChanged.connect(log_mag_update)
        self.checkBoxLogFreq.stateChanged.connect(log_freq_update)
        self.checkBoxLocked.stateChanged.connect(locked_change)
        self.pushButtonModel.clicked.connect(mc.do_model)
        self.actionSave_Plots.triggered.connect(write_plots)
        self.radioButtonNormDenormOn.pressed.connect(self.norm_denorm_on)
        self.radioButtonNormDenormOff.pressed.connect(self.norm_denorm_off)
        self.lineEditData.installEventFilter(self.QLineEditDropHandler(self))

        # Connect matplotlib events to functions
        self.mpl.canvas.mpl_connect("button_press_event", on_click)
        self.mpl.canvas.mpl_connect("pick_event", on_pick)

    class QLineEditDropHandler(QtCore.QObject):
        """ Handles drag/drop file names on the data file edit box """

        def __init__(self, parent=None):
            QtCore.QObject.__init__(self, parent)

        def eventFilter(self, obj, event):
            if event.type() == QtCore.QEvent.DragEnter:
                # we need to accept this event explicitly to be able to receive QDropEvents
                if event.mimeData().hasUrls:
                    event.accept()
                else:
                    event.ignore()
            if event.type() == QtCore.QEvent.Drop:
                # This convoluted statement extracts just one URL even if several
                # have been dropped:
                url_filename = event.mimeData().urls()[0].url()
                # Trim the 'file:///' from the beginning of the dropped string and convert
                # to local path
                file = os.path.normpath(url_filename[8:])
                obj.setText(file)
                reg.set_reg("DataFilename", file)
                read_and_plot_data_file(file)
                event.accept()
            return QtCore.QObject.eventFilter(self, obj, event)

    def exc_dialog(self, str_list):
        """ Put up a dialog box with the error strings
        captured by traceback for an unhandled exception """
        self.err_box = QtWidgets.QMessageBox()
        self.err_box.setWindowTitle("Zfit Error")
        err_text = ""
        for string in str_list:
            err_text += string
        self.err_box.setText(err_text)
        self.err_box.show()

    def norm_denorm_on(self):
        # Enable normalization around modeling
        self.radioButtonNormDenormOn.setChecked(True)
        self.radioButtonNormDenormOff.setChecked(False)
        self.do_norm_denorm = True
        reg.set_reg("Normalize", "True")


    def norm_denorm_off(self):
        # Disable normalization around modeling
        self.radioButtonNormDenormOn.setChecked(False)
        self.radioButtonNormDenormOff.setChecked(True)
        self.do_norm_denorm = False
        reg.set_reg("Normalize", "False")

class Range:
    """
    This class is a holder for global data pertaining to the x or
    abscissa range.
    """
    def __init__(self):
        self.xa = {"Hz": None, "omega": None}
        self.load_array = None
        self.segment_str = ""
        self.segment_index = 0

    def data_bundle(self):
        # Return a list of copies of the current data
        x = copy.copy(self.xa)
        l = copy.copy(self.load_array)
        s = copy.copy(self.segment_str)
        return [x, l, s]

    def data_unbundle(self, group):
        # Complement of function above
        self.xa = group[0]
        self.load_array = group[1]
        self.segment_str = group[2]


def zfit_excepthook(type, value, tb):
    """ Unhandled exceptions are sent here.
    Use traceback to capture error string list and send to
    main window for dialog display. """
    import traceback
    amw.exc_dialog(traceback.format_exception(type, value, tb))

def draw_weight():
    amw.pushButtonDraw.setText('&Draw Weight')
    amw.pushButtonDraw.setShortcut('D')
    amw.pushButtonClear.setText('&Clear Weight')
    amw.pushButtonClear.setShortcut('C')
    ya.select(W)

def draw_mag():
    amw.pushButtonDraw.setText('&Draw Magnitude')
    amw.pushButtonDraw.setShortcut('D')
    amw.pushButtonClear.setText('&Clear Magnitude')
    amw.pushButtonClear.setShortcut('C')
    ya.select(M)

def draw_pha():
    amw.pushButtonDraw.setText('&Draw Phase')
    amw.pushButtonDraw.setShortcut('D')
    amw.pushButtonClear.setText('&Clear Phase')
    amw.pushButtonClear.setShortcut('C')
    ya.select(P)

def locked_change():
    # Get keys & params from data file save/edit, display in Parameters box
    print_results()
    if amw.checkBoxLocked.isChecked():
        amw.groupBoxNormDenorm.setEnabled(False)
        amw.comboBoxMethod.setEnabled(False)
        amw.label_Method.setEnabled(False)
    else:
        amw.groupBoxNormDenorm.setEnabled(True)
        amw.comboBoxMethod.setEnabled(True)
        amw.label_Method.setEnabled(True)


def clear_active_axes():
    ix = ya.index

    # Remove all added plot lines (includes drawn points), but leave data
    for line in ya.ax[ix].get_lines():
        if line.get_label() != "Zdata":
            line.remove()

    # Null array for drawn models
    if ix != W:
        ya.drawnData[ix] = None
    else:
        # Default weighting curve is all 1's
        ya.drawnData[W] = np.ones(len(ya.inputData[M]))

    # Clear text windows
    amw.labelStatus.setText("")
    if not amw.checkBoxLocked.isChecked() and ix != W:
        # Don't clear parameters if active axes = weight or if
        # params are locked
        amw.labelParams.setText("")
    draw_formatted()


def read_and_plot_data_file(file):

    class Data:
        """
        A class to hold data structures used locally and to perform common
        append operations
        """
        def __init__(self):
            self.reset()

        def reset(self):
            # Set default and empty variables
            self.hz, self.omega, self.mag, self.pha, self.load = [], [], [], [], []
            self.segment_str = ""
            self.segment_code = compile("1", "<string>", "eval")

        def append(self):
            # Copy local lists to working arrays
            range.xa["Hz"] = np.array(self.hz)
            range.xa["omega"] = np.array(self.omega)
            ya.inputData[M] = np.array(self.mag)
            ya.inputData[P] = np.array(self.pha)
            range.load_array = np.array(self.load)
            range.segment_str = self.segment_str
            # Append working arrays to segment lists
            ya_list.append(ya.data_bundle())
            range_list.append(range.data_bundle())

    while True:
        # Clear any existing data, drawn, or modeling lines
        for ax in ya.ax:
            for line in ax.get_lines():
                line.remove()

        # Clear text windows
        amw.labelStatus.setText("")
        if not amw.checkBoxLocked.isChecked():
            amw.labelParams.setText("")

        # Clear axes data
        ya.inputData = [None, None, None]
        ya.modeledData = [None, None, None]
        ya.drawnData = [None, None, None]

        # Clear data segment lists
        ya_list.clear()
        range_list.clear()

        # Create and clear local data class
        d = Data()
        d.reset()
        try:
            # Read and plot impedance data to lists from CSV file with one header line
            # (use lists instead of ndarrays because appending to ndarrays doesn't work well)
            # There may be several segments with <segment> lines between them.  Append each
            # segment to a local list.
            with open(file, "r", encoding="utf-8", newline='') as f:
                # Skip single header line
                next(f)
                for line in f:
                    if line[:9] == "<segment>":
                        # <segment> line defines break between segments, or the first segment.
                        # May or may not be present.
                        if d.hz:
                            # Data exists in d, append segment just read
                            d.append()
                        # Starting a new data segment
                        d.reset()
                        d.segment_str = line[9:].strip()
                        try:
                            # Compile segment expression (may simply be a comment)
                            d.segment_code = compile(d.segment_str, "<string>", "eval")
                        except:
                            d.reset()
                    else:
                        # Read freq, mag, and phase
                        elems = line.strip().split(',')
                        freq = float(elems[0])
                        d.hz.append(freq)
                        d.mag.append(float(elems[1]))
                        d.pha.append(float(elems[2]))
                        # Calculate radian freq and complex load (if provided)
                        w = 2.0*np.pi*freq
                        d.omega.append(w)
                        j = 1j
                        # w and j are now defined for use in load expression
                        d.load.append(eval(d.segment_code))
            # Successful loading of data file, break from while loop
            break
        except:
            # Pick a data file and loop again
            start = path.dirname(amw.lineEditData.text())
            file = QtWidgets.QFileDialog.getOpenFileName(caption="Data File", directory=start,
                                                         filter="CSV files (*.csv)")[0]
            file = path.normpath(file)
            amw.lineEditData.setText(file)
            reg.set_reg("DataFilename", file)

    # Final append for data with no <segment> or for last <segment> segment.
    # The last segment in the list is the one being displayed.
    d.append()
    range.segment_index = len(ya_list) - 1

    # Display segment string if segment is present
    if not range.segment_str:
        amw.lineEditSegment.setEnabled(False)
        amw.label_Segment.setEnabled(False)
        amw.lineEditSegment.setText("(none)")
    else:
        amw.lineEditSegment.setEnabled(True)
        amw.label_Segment.setEnabled(True)
        amw.lineEditSegment.setText(range.segment_str)

    # Enable drawing curves & disable Next if only one segment is present
    if len(ya_list) == 1:
        amw.groupBoxDrawing.setEnabled(True)
        amw.pushButtonNext.setEnabled(False)
    else:
        amw.groupBoxDrawing.setEnabled(False)
        amw.pushButtonNext.setEnabled(True)

    # Add input data to plot
    ya.ax[M].plot(range.xa["Hz"], ya.inputData[M], ".", ms=3, color=M_COLOR, label="Zdata")
    ya.ax[P].plot(range.xa["Hz"], ya.inputData[P], ".", ms=3, color=P_COLOR, label="Zdata")

    # Default weighting curve is all 1's
    ya.drawnData[W] = np.ones(len(ya.inputData[M]))

    draw_formatted()


def next_plot():
    # 'Next' button click:
    # Button is enabled, so multiple data segments exist.
    # Clear any existing data, drawn, or modeling lines
    for ax in ya.ax:
        for line in ax.get_lines():
            line.remove()

    range.segment_index += 1
    if range.segment_index >= len(ya_list):
        range.segment_index = 0
    ya.data_unbundle(ya_list[range.segment_index])
    range.data_unbundle(range_list[range.segment_index])
    amw.lineEditSegment.setText(range.segment_str)

    ya.ax[M].plot(range.xa["Hz"], ya.inputData[M], ".", ms=3, color=M_COLOR, label="Zdata")
    ya.ax[P].plot(range.xa["Hz"], ya.inputData[P], ".", ms=3, color=P_COLOR, label="Zdata")
    if ya.modeledData[M] is not None:
        ya.ax[M].plot(range.xa["Hz"], ya.modeledData[M], ya.modeledLinePlot[M],
                      ls=ya.modeledLineStyle[M], lw=1, label="modeledZPlot")
        ya.ax[P].plot(range.xa["Hz"], ya.modeledData[P], ya.modeledLinePlot[P],
                      ls=ya.modeledLineStyle[P], lw=1, label="modeledZPlot")

    draw_formatted()


def axes_init(amw):
    # Save the figure instance to which the axes belong, and set background
    ya.fig = amw.mpl.canvas.ax.get_figure()
    ya.fig.patch.set_facecolor('white')

    # Create all axes
    ya.ax[M] = amw.mpl.canvas.ax
    ya.ax[P] = ya.ax[M].twinx()
    ya.ax[W] = ya.ax[M].twinx()

    # Weight axis display off, set limits
    ya.ax[W].axis('off')
    ya.ax[W].set_ylim(1, MAX_MODEL_WEIGHT)

    # Set mag/phase x-axes to engineering units
    formatter = EngFormatter(unit="Hz", places=1)
    ya.ax[M].xaxis.set_major_formatter(formatter)
    ya.ax[P].xaxis.set_major_formatter(formatter)

    ya.select(ya.index)

    # Labels, grids, colors
    ya.ax[M].set_xlabel("FREQUENCY")
    ya.ax[P].set_xlabel("FREQUENCY")
    ya.ax[M].xaxis.grid(True, which="both", color='0.65')
    ya.ax[P].xaxis.grid(True, which="both", color='0.65')

    # Set label & grid colors for mag and phase
    for ix in (M, P):
        ya.ax[ix].set_ylabel(ya.axis_label[ix], color=ya.dataColor[ix])
        for label in ya.ax[ix].get_yticklabels():
            label.set_color(ya.dataColor[ix])
        ya.ax[ix].yaxis.grid(True, which="both", color=ya.dataColor[ix], alpha=0.3, linestyle='dashed')

    # Set log axes if necessary
    if amw.checkBoxLogMag.isChecked():
        ya.ax[M].set_yscale("log")
    else:
        ya.ax[M].set_yscale("linear")
    if amw.checkBoxLogFreq.isChecked():
        ya.ax[M].set_xscale("log")
        ya.ax[P].set_xscale("log")
    else:
        ya.ax[M].set_xscale("linear")
        ya.ax[P].set_xscale("linear")

    data_file = amw.lineEditData.text()
    if data_file != "":
        read_and_plot_data_file(data_file)


def select_data_file():
    start = path.dirname(amw.lineEditData.text())
    file = QtWidgets.QFileDialog.getOpenFileName(caption="Data File", directory=start,
                                             filter="CSV files (*.csv)")[0]
    if file:
        file = path.normpath(file)
        amw.lineEditData.setText(file)
        reg.set_reg("DataFilename", file)
        read_and_plot_data_file(file)
        # Clear text windows
        amw.labelStatus.setText("")
        if not amw.checkBoxLocked.isChecked():
            amw.labelParams.setText("")

def select_model_script():
    file = QtWidgets.QFileDialog.getOpenFileName(caption="Select Model Script",
                                             directory=r".\Models",
                                             filter="Python scripts (*.py)")[0]
    if file:
        file = os.path.basename(file)
        script = os.path.splitext(file)[M]
        amw.lineEditModel.setText(script)
        reg.set_reg("ModelScript", script)
        # Clear text windows
        amw.labelStatus.setText("")
        if not amw.checkBoxLocked.isChecked():
            amw.labelParams.setText("")


def edit_model_script():
    if amw.lineEditModel.text != "":
        filename = "Models\\" + amw.lineEditModel.text() + ".py"
        # procedure below is from
        # http://stackoverflow.com/questions/3005437/windowserror-error-5-access-is-denied
        commandLine = [EDITOR, filename]
        appPath = os.path.join(EDIT_PATH, EDITOR)
        subprocess.Popen(commandLine, executable=appPath)


def on_click(event):
    # 'event' applies to the currently active axes
    if (event.inaxes is None) or (event.button != 1) or (len(ya_list) > 1):
        # Click is outside axes or not left-click, or multiple data segments exist
        return
    # Get index for axis-dependent selections
    ix = ya.index
    # .xdata and .ydata are in data coords for the active axes
    ya.ax[ix].plot(event.xdata, event.ydata, marker="s", ms=4,
                   color=ya.dataColor[ix], picker=5,
                   label="drawnPoint")
    draw_formatted()


def on_pick(event):
    # When the user right-clicks on a point, remove it
    if event.mouseevent.button != 3:
        return
    if event.artist.get_label() == "drawnPoint":
        event.artist.remove()
        draw_formatted()


def print_results(params=None):
    # Print model names & values to output text box.
    # Labels are rich text, need to use <br> for newline.
    if amw.checkBoxLocked.isChecked():
        outstr = RICH_TEXT_RED
    else:
        outstr = ""

    names, values = [], []
    if params == None:
        # Read keys & params from file if not provided
        with open(PARAM_FILE, mode='r', encoding='utf-8', newline='') as f:
            reader = csv.reader(f)
            next(f)      # skip header line
            for line in reader:
                names.append(line[0])
                values.append(float(line[1]))
    else:
        # list of tuples is supplied.
        for p in params:
            names.append(p[0])
            values.append(p[1])
    for name, val in zip(names, values):
        outstr += name + " = "
        # Must replace '<' and '>' in rich text
        valstr = ut.eng_notate(val, d=4, neg_ok=ALLOW_NEG)
        valstr = valstr.replace('<', '&lt;')
        valstr = valstr.replace('>', '&gt;')
        outstr += valstr + "<br>"
    if amw.checkBoxLocked.isChecked():
        outstr += "<br>Read from<br>" + PARAM_FILE
    amw.labelParams.setText(outstr)


def method_update():
    new_index = amw.comboBoxMethod.currentIndex()
    reg.set_reg("MethodIndex", str(new_index))
    draw_formatted()


def draw_active():
    ix = ya.index
    pointcoord = []

    # Remember drawnPlot coordinates, delete existing drawnPlot line
    for line in ya.ax[ix].get_lines():
        if line.get_label() == "drawnPoint":
            pointcoord.append(line.get_data())
        if line.get_label() == "drawnPlot":
            line.remove()

    if pointcoord == []:
        # No points to draw
        return

    # Clear text windows
    amw.labelStatus.setText("")
    if not amw.checkBoxLocked.isChecked():
        amw.labelParams.setText("")
    pointcoord = np.array(pointcoord)[..., 0]

    # Sort the drawnPlot-point-array according to the x-values
    sort_array = np.argsort(pointcoord[:, 0])
    x, y = pointcoord[sort_array].T

    # Create linear interpolation function between drawn points
    lin_interp = UnivariateSpline(x, y, k=2, s=0.0)
    # Interpolate
    ya.drawnData[ix] = lin_interp(range.xa["Hz"])

    # Make sure weights don't go below 1.0
    if ix == W:
        for point in ya.drawnData[ix]:
            if point < 1.0:
                point = 1.0

    # Add drawn plot
    ya.ax[ix].plot(range.xa["Hz"], ya.drawnData[ix], ya.drawnLinePlot[ix],
                   ls="-", lw=1, label="drawnPlot")
    draw_formatted()


def log_mag_update():
    checked = amw.checkBoxLogMag.isChecked()
    if checked:
        ya.ax[M].set_yscale("log")
    else:
        ya.ax[M].set_yscale("linear")

    reg.set_reg("LogMag", str(checked))

    draw_formatted()


def log_freq_update():
    checked = amw.checkBoxLogFreq.isChecked()
    if checked:
        ya.ax[M].set_xscale("log")
        ya.ax[P].set_xscale("log")
    else:
        ya.ax[M].set_xscale("linear")
        ya.ax[P].set_xscale("linear")

    reg.set_reg("LogFreq", str(checked))

    draw_formatted()
    

def write_plots():
    # Get plot path, save new
    path = QtWidgets.QFileDialog.getExistingDirectory(caption="Zfit plot folder", directory=amw.plot_file_path)
    reg.set_reg("LastPlotPath", path)
    # Construct file names & write plots
    png_file = path + r"\Zfit.png"
    svg_file = path + r"\Zfit.svg"
    # Save the plots with boundaries "tight" to the axes (no wasted space)
    ya.fig.savefig(png_file, bbox_inches="tight")
    ya.fig.savefig(svg_file, bbox_inches="tight")


def draw_formatted():
    # This is necessary because the plot limits don't autoscale properly all the time.
    # Refresh both Y axis autoscale limits before checking log scales. .relim() and
    # .autoscale_view() seem to work fine for data, spline, and model lines on a linear
    # scale.
    for ax in (W, M, P):
        ya.ax[ax].relim()
        ya.ax[ax].autoscale_view()

    # Need to force log bounds or they default to decades
    if amw.checkBoxLogFreq.isChecked():
        ya.ax[M].set_xbound(lower=range.xa["Hz"].min(), upper=range.xa["Hz"].max())
        ya.ax[P].set_xbound(lower=range.xa["Hz"].min(), upper=range.xa["Hz"].max())
    if amw.checkBoxLogMag.isChecked():
        # Check data, spline, and model lines for min/max
        bmax, bmin = 0.0, 0.0
        for line in ya.ax[M].get_lines():
            bmax = max(bmax, max(line._y))
            bmin = min(bmin, min(line._y))
        ya.ax[M].set_ybound(lower=.83 * bmin, upper=1.2 * bmax)

    # Need to set formatter again if X scale was changed
    formatter = EngFormatter(unit="Hz", places=1)
    ya.ax[M].xaxis.set_major_formatter(formatter)
    ya.ax[P].xaxis.set_major_formatter(formatter)

    # Finally do the draw
    amw.mpl.canvas.draw()


def show_help():
    os.startfile("ZfitHelp.pdf")


# START OF MAIN SCRIPT =====================================================================
if __name__ == "__main__":
    from matplotlib.ticker import EngFormatter
    from scipy.interpolate import UnivariateSpline
    import numpy as np
    import sys
    import csv
    import os
    from os import path
    import utils as ut  # local copy

    # import the MainWindow widget from the converted .ui file
    import subprocess
    import copy
    # Zfit modules:
    from zfit_constants import *
    import zfit_modelcore
    import zfit_yaxes
    import zfit_registry as reg

    # Instantiate class to keep track of the active Y axis
    ya = zfit_yaxes.YAxes(W)
    # Keep a list of mag, pha, and weight data for all data segments here
    ya_list = []
    # Instantiate range class
    range = Range()
    # Keep a list of load data for all data segments here
    range_list = []
    
    # Instantiate and link the modeling class
    mc = zfit_modelcore.DoModel()
    mc.ya = ya
    mc.ya_list = ya_list
    mc.range = range
    mc.range_list = range_list
    mc.print_results = print_results
    mc.draw_formatted = draw_formatted

    # Create the GUI application, with an overall GUI style.
    # Can use 'Windows', 'WindowsXP', 'WindowsVista', or 'Fusion' below.
    # Can also use .setStyleSheet to use a .qss file?
    QtWidgets.QApplication.setStyle(QtWidgets.QStyleFactory.create("Fusion"));
    app = QtWidgets.QApplication(sys.argv)
    # Instantiate the main window
    amw = AppMainWindow()
    # Initialize and show axes
    axes_init(amw)
    amw.show()

    # link modeling interface to app main window
    mc.amw = amw

    # Route exceptions to a custom handler, so Zfit doesn't crash on them.
    # This is important since errors in model scripts are likely during use.
    sys.excepthook = zfit_excepthook

    # start the Qt main loop execution, exiting from this script
    # with the same return code of Qt application
    sys.exit(app.exec_())
